<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è¯­éŸ³æ–‡å­—é›¨ v3.0 (æé€Ÿç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        /* éšè—åŸå§‹è§†é¢‘ï¼Œåªæ˜¾ç¤ºCanvas */
        #webcam { display: none; }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* ç•Œé¢UIå±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .status-panel {
            background: rgba(0, 0, 0, 0.65);
            color: white;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            max-width: 320px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 10px 0; font-size: 18px; color: #00ff9d; letter-spacing: 1px; display: flex; align-items: center; gap: 10px; }
        .live-indicator { width: 10px; height: 10px; background: #ff4757; border-radius: 50%; animation: pulse 1s infinite; }
        
        .info-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 14px; color: #ddd; }
        .highlight { color: #fff; font-weight: bold; }
        .sub-text { font-size: 12px; color: #aaa; margin-top: 5px; line-height: 1.4; }

        .controls { margin-top: 15px; pointer-events: auto; display: flex; gap: 10px; }
        button {
            background: #333; color: white; border: 1px solid #666;
            padding: 6px 12px; cursor: pointer; border-radius: 6px; font-size: 12px;
            transition: all 0.2s;
        }
        button:hover { background: #555; border-color: #888; }
        button:active { transform: translateY(1px); }

        /* é—­çœ¼è­¦å‘ŠåŠ¨ç”» */
        #eye-progress-container {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            pointer-events: none;
        }
        .circular-chart { width: 160px; height: 160px; }
        .circle-bg { fill: none; stroke: rgba(255,255,255,0.1); stroke-width: 3; }
        .circle { 
            fill: none; stroke-width: 4; stroke: #ff4757; stroke-linecap: round; 
            transition: stroke-dashoffset 0.1s linear;
            filter: drop-shadow(0 0 5px #ff4757);
        }
        .warning-text {
            color: #ff4757; font-size: 24px; font-weight: 900; margin-top: 15px;
            text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(255, 71, 87, 0.5);
        }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div class="status-panel">
            <h1><div class="live-indicator"></div> è¯­éŸ³æ–‡å­—é›¨ Pro</h1>
            <div class="info-row">
                <span>ç³»ç»ŸçŠ¶æ€:</span>
                <span id="status-text" class="highlight">åˆå§‹åŒ–ä¸­...</span>
            </div>
            <div class="info-row">
                <span>å½“å‰è¯†åˆ«:</span>
                <span id="speech-result" style="color: #ffd700; max-width: 150px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">...</span>
            </div>
            <div class="sub-text">
                ğŸ—£ï¸ è¯´è¯ï¼šæ–‡å­—æé€Ÿæ‰è½
            </div>
            <div class="controls">
                <button onclick="manualDrop()">ğŸ§ª æµ‹è¯•æ‰è½</button>
                <button onclick="resetWorld()">ğŸ—‘ï¸ æ¸…ç©ºå±å¹•</button>
            </div>
        </div>
    </div>

    <div id="eye-progress-container">
        <svg viewBox="0 0 36 36" class="circular-chart">
            <path class="circle-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
            <path id="progress-circle" class="circle" stroke-dasharray="100, 100" stroke-dashoffset="100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        </svg>
        <div class="warning-text">å³å°†çˆ†ç‚¸</div>
    </div>

    <script type="module">
        import { FilesetResolver, SelfieSegmentation } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        const CONFIG = {
            EXPLOSION_TIME: 5000,
            BLINK_THRESHOLD: 0.60, // é—­çœ¼é˜ˆå€¼ï¼Œå»ºè®®0.55-0.65ä¹‹é—´
            GRAVITY: 1.5,          // é‡åŠ›åŠ é€Ÿåº¦ï¼Œè¶Šå¤§æ‰å¾—è¶Šå¿«
            FONT_SIZE_MIN: 30,
            FONT_SIZE_MAX: 55
        };

        let engine, world, runner;
        let canvas, ctx, video, selfieSegmentation;
        let lastVideoTime = -1;
        let textBodies = [];
        let recognition;
        let wordFrequencies = {}; // æ–°å¢ï¼šç”¨äºè¿½è¸ªè¯é¢‘
        let staticPersonBodies = []; // æ–°å¢ï¼šç”¨äºå­˜å‚¨äººå½¢è¾¹ç•Œ
        let tempCanvas, tempCtx; // æ–°å¢ï¼šç”¨äºå¤„ç†å›¾åƒ

        // --- åˆå§‹åŒ– ---
        async function init() {
            const status = document.getElementById('status-text');
            video = document.getElementById('webcam');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶ç”»å¸ƒç”¨äºå¤„ç†å›¾åƒ
            tempCanvas = document.createElement('canvas');
            tempCtx = tempCanvas.getContext('2d');

            initPhysics();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 1. æ‘„åƒå¤´
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 360, facingMode: "user" }, audio: false 
                });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = r);
                video.play();
            } catch (err) {
                status.innerText = "âŒ æ‘„åƒå¤´è¢«æ‹’ç»";
                status.style.color = "red";
                return;
            }

            // 2. MediaPipe Selfie Segmentation æ¨¡å‹
            try {
                status.innerText = "åŠ è½½ AI æ¨¡å‹...";
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                selfieSegmentation = await SelfieSegmentation.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/selfie_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    outputCategoryMask: true,
                });
                status.innerText = "âœ… ç³»ç»Ÿå°±ç»ª";
                status.style.color = "#00ff9d";
            } catch (err) {
                console.error(err);
                status.innerText = "âŒ AI åŠ è½½å¤±è´¥";
            }

            // 3. è¯­éŸ³è¯†åˆ« (æé€Ÿç‰ˆ)
            initFastSpeech();

            // 4. å¾ªç¯
            requestAnimationFrame(loop);
        }

        // --- ç‰©ç†å¼•æ“ ---
        function initPhysics() {
            const Engine = Matter.Engine, World = Matter.World, Runner = Matter.Runner;
            engine = Engine.create();
            world = engine.world;
            engine.gravity.y = CONFIG.GRAVITY;
            
            createStaticBoundaries(); // åˆ›å»ºåœ°é¢

            runner = Runner.create();
            Runner.run(runner, engine);
        }

        // åˆ›å»ºé™æ€è¾¹ç•Œï¼ˆå¦‚åœ°é¢ï¼‰
        function createStaticBoundaries() {
            // ç§»é™¤æ—§çš„åœ°é¢ï¼Œä»¥é˜²ä¸‡ä¸€
            const oldGround = world.bodies.find(b => b.label === 'ground');
            if(oldGround) Matter.World.remove(world, oldGround);

            const w = window.innerWidth, h = window.innerHeight;
            const ground = Matter.Bodies.rectangle(w/2, h + 50, w, 100, { 
                isStatic: true, 
                label: 'ground',
                render: { visible: false } 
            });
            Matter.World.add(world, [ground]);
        }

        window.addTextBody = function(text) {
            // æ›´æ–°è¯é¢‘
            wordFrequencies[text] = (wordFrequencies[text] || 0) + 1;
            const frequency = wordFrequencies[text];

            const fontSize = CONFIG.FONT_SIZE_MIN + Math.random() * (CONFIG.FONT_SIZE_MAX - CONFIG.FONT_SIZE_MIN);
            ctx.font = `bold ${fontSize}px Arial`;
            const metrics = ctx.measureText(text);
            const width = metrics.width + 14;
            const height = fontSize + 6;

            const x = Math.random() * (canvas.width - 100) + 50;
            const y = -50 - Math.random() * 50;

            const body = Matter.Bodies.rectangle(x, y, width, height, {
                restitution: 0.4,
                friction: 0.3,
                density: 0.04,
                angle: (Math.random() - 0.5) * 0.5
            });

            body.renderText = text;
            
            // æ ¹æ®è¯é¢‘å†³å®šé¢œè‰²
            if (frequency <= 2) { // ç¬¬ä¸€æ¬¡æˆ–ç¬¬äºŒæ¬¡å‡ºç°
                body.renderBgColor = '#FFFFFF';
                body.renderTextColor = '#000000';
            } else {
                // å¤šæ¬¡å‡ºç°åï¼Œå¼€å§‹å˜å½©è‰²
                const hue = (text.charCodeAt(0) * 137.5) % 360; // åŸºäºæ–‡å­—ç»™ä¸€ä¸ªå›ºå®šçš„è‰²ç›¸
                const saturation = Math.min(30 + frequency * 5, 100);
                const lightness = Math.max(70 - frequency * 2, 50);
                body.renderBgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                body.renderTextColor = '#FFFFFF';
            }

            body.renderFontSize = fontSize;
            
            Matter.World.add(world, body);
            textBodies.push(body);
        }

        // --- æé€Ÿè¯­éŸ³è¯†åˆ«æ ¸å¿ƒé€»è¾‘ (v2.0 ä¼˜åŒ–ç‰ˆ) ---
        let lastTranscript = ''; // æŒç»­è¿½è¸ªä¸Šä¸€æ¬¡çš„è¯†åˆ«ç»“æœ
        function initFastSpeech() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return alert("è¯·ä½¿ç”¨ Chrome æµè§ˆå™¨");

            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'zh-CN';

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                // éå†æ‰€æœ‰ç»“æœï¼Œæ‹¼æ¥æˆå®Œæ•´å¥å­
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                
                const currentTranscript = finalTranscript || interimTranscript;
                document.getElementById('speech-result').innerText = currentTranscript;

                // æ‰¾å‡ºæ–°å¢çš„æ–‡æœ¬
                if (currentTranscript.length > lastTranscript.length) {
                    const newContent = currentTranscript.substring(lastTranscript.length);
                    processAndDrop(newContent);
                }
                
                lastTranscript = currentTranscript;

                // å¦‚æœä¸€å¥è¯ç»“æŸäº†ï¼Œå°±æ¸…ç©ºè®°å½•ï¼Œé¿å…ä¸‹æ¬¡å¯¹æ¯”å‡ºé”™
                if (finalTranscript) {
                    lastTranscript = '';
                }
            };

            recognition.onerror = (event) => {
                console.error("è¯­éŸ³è¯†åˆ«é”™è¯¯:", event.error);
            };

            recognition.onend = () => {
                // æ„å¤–ç»“æŸåè‡ªåŠ¨é‡å¯
                try { 
                    recognition.start(); 
                } catch(e){
                    console.error("è¯­éŸ³è¯†åˆ«é‡å¯å¤±è´¥:", e);
                }
            };

            recognition.start();
        }

        function processAndDrop(text) {
            const content = text.trim();
            if (!content) return;

            // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
            if (/[\u4e00-\u9fa5]/.test(content)) {
                // å¯¹äºåŒ…å«ä¸­æ–‡çš„æ–‡æœ¬ï¼Œé€å­—æ‰è½
                for (let char of content) {
                    if (char.trim()) {
                        window.addTextBody(char);
                    }
                }
            } else {
                // å¯¹äºè‹±æ–‡æˆ–æ•°å­—ï¼ŒæŒ‰ç©ºæ ¼åˆ†å‰²æˆå•è¯æ‰è½
                const words = content.split(/\s+/);
                words.forEach(word => {
                    if (word) {
                        window.addTextBody(word);
                    }
                });
            }
        }

        // --- æ¸²æŸ“ä¸é€»è¾‘å¾ªç¯ ---
        function loop() {
            // 1. è·å–äººä½“è½®å»“
            if (selfieSegmentation && video.readyState === 4 && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                selfieSegmentation.segmentForVideo(video, performance.now(), (result) => {
                    // æ ¹æ®è½®å»“æ›´æ–°ç‰©ç†è¾¹ç•Œ
                    updateBoundariesFromMask(result.categoryMask);
                });
            }

            // 2. ç»˜åˆ¶è§†é¢‘ï¼ˆå¯ä»¥å…³é—­ä»¥æé«˜æ€§èƒ½ï¼‰
            // ctx.save();
            // ctx.translate(canvas.width, 0);
            // ctx.scale(-1, 1);
            // ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            // ctx.restore();

            // 3. æ¸…ç©ºç”»å¸ƒï¼Œå‡†å¤‡ç»˜åˆ¶æ–‡å­—
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 4. ç»˜åˆ¶ç‰©ç†æ–‡å­—
            drawPhysicsBodies();

            requestAnimationFrame(loop);
        }

        function updateBoundariesFromMask(mask) {
            if (!mask) return;

            const MASK_DOWNSAMPLE = 4; // é™ä½é‡‡æ ·ç‡ä»¥æé«˜æ€§èƒ½
            const PERSON_RADIUS = 4;

            // 1. å°† mask ç»˜åˆ¶åˆ°ä¸´æ—¶ç”»å¸ƒ
            const maskWidth = mask.width;
            const maskHeight = mask.height;
            tempCanvas.width = maskWidth;
            tempCanvas.height = maskHeight;
            tempCtx.putImageData(mask, 0, 0);

            // 2. ç§»é™¤æ—§çš„è¾¹ç•Œ
            if (staticPersonBodies.length > 0) {
                Matter.World.remove(world, staticPersonBodies);
                staticPersonBodies = [];
            }

            // 3. éå†åƒç´ å¹¶åˆ›å»ºæ–°çš„è¾¹ç•Œç²’å­
            const imageData = tempCtx.getImageData(0, 0, maskWidth, maskHeight).data;
            const scaleX = canvas.width / maskWidth;
            const scaleY = canvas.height / maskHeight;

            for (let y = 0; y < maskHeight; y += MASK_DOWNSAMPLE) {
                for (let x = 0; x < maskWidth; x += MASK_DOWNSAMPLE) {
                    const index = (y * maskWidth + x) * 4;
                    // å¦‚æœåƒç´ çš„ alpha é€šé“ > 0ï¼Œè¯´æ˜è¿™é‡Œæ˜¯â€œäººâ€
                    if (imageData[index + 3] > 0) {
                        const body = Matter.Bodies.circle(
                            canvas.width - (x * scaleX), // é•œåƒåè½¬Xåæ ‡
                            y * scaleY,
                            PERSON_RADIUS,
                            { 
                                isStatic: true,
                                render: { visible: false } // è¾¹ç•Œä¸å¯è§
                            }
                        );
                        staticPersonBodies.push(body);
                    }
                }
            }

            // 4. å°†æ–°çš„è¾¹ç•Œç²’å­æ·»åŠ åˆ°ä¸–ç•Œ
            Matter.World.add(world, staticPersonBodies);
        }

        window.manualDrop = function() {
            const s = "å¤©åœ°ç„é»„å®‡å®™æ´ªè’";
            window.addTextBody(s[Math.floor(Math.random()*s.length)]);
        }

        window.resetWorld = function() {
            // ç§»é™¤æ‰€æœ‰æ–‡å­—
            Matter.World.remove(world, textBodies);
            textBodies = [];

            // ç§»é™¤æ‰€æœ‰äººå½¢è¾¹ç•Œ
            if (staticPersonBodies.length > 0) {
                Matter.World.remove(world, staticPersonBodies);
                staticPersonBodies = [];
            }

            // é‡ç½®è¯é¢‘
            wordFrequencies = {};
        }

        function drawPhysicsBodies() {
            textBodies.forEach(body => {
                const pos = body.position;
                const angle = body.angle;

                // ä¼˜åŒ–ï¼šå±å¹•å¤–çš„ç‰©ä½“ä¸ç»˜åˆ¶ï¼Œä½†MatterJSè¿˜åœ¨ç®—
                if (pos.y > canvas.height + 100) return;

                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(angle);

                // ç»˜åˆ¶åœ†è§’èƒŒæ™¯
                const w = body.bounds.max.x - body.bounds.min.x;
                const h = body.bounds.max.y - body.bounds.min.y;
                
                ctx.fillStyle = body.renderBgColor;
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 5;
                
                ctx.beginPath();
                ctx.roundRect(-w/2, -h/2, w, h, 6);
                ctx.fill();
                
                // ç»˜åˆ¶æ–‡å­—
                ctx.fillStyle = body.renderTextColor;
                ctx.shadowBlur = 0;
                ctx.font = `bold ${body.renderFontSize}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(body.renderText, 0, 2);

                ctx.restore();
            });
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createStaticBoundaries(); // çª—å£å˜åŒ–æ—¶é‡å»ºåœ°é¢
        }

        window.onload = init;
    </script>
</body>
</html>